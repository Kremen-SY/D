# Автоматизация бизнес-процессов.
1.	Дата: 26.05.2023
2.	Контекст: Бизнес-процесс – набор связанных задач для создания продукта или услуги. BPM (business process management) – концепция рассматривающая бизнес как совокупность процессов. BPMS (business process management system) – ПО для поддержки концепции BPM. Требуется выбрать паттерн организации бизнес-процессов, в частности нужно ли применять BPMS.
3.	Опции:

    3.1.	“State machine”. Логика представляет из себя автомат конечных состояний. Самый простой и относительно гибкий метод. Недостатки: отсутствие стандартизированного описания процесса, необходимость тестирования процесса, потребность в хранении и передаче информации между задачами.

    3.2.	“Petri Nets”. Логика представляет из себя сети Петри. Недостатки: те же что в опции 1 е еще это очень негибкий метод.

    3.3.	“Pure Code”. Применение паттерна “цепочка ответственности” из плюсов — это гибкая и тестируемая методология.

    3.4.	“Queues”. Использовать очереди сообщений. В брокере сообщений создаются топики под каждую конкретную задачу. Задачи можно забирать из топиков и складывать в другие топики. – это менее гибкий и менее наблюдаемый вариант.

    3.5.	“Workflow” – инструменты для организации   workflow (Conductor, Cadence). ИЗ плюсов – наблюдаемость, относительная гибкость, тестируемость и скорость разработки.

    3.6.	“BPMS” использовать BPM-движок (например, Camunda). BPMS управляет процессом (условные переходы, использование задач в рамках процесса в определенном порядке). Информация необходимая для процесса хранится в контексте процесса. Каждый процесс имеет доступ только к своему контексту. Следует использовать, если процессы длительные во времени, используют сложную логику, используется много систем и постоянно развиваются. Из плюсов наблюдаемость, тестируемость, скорость разработки, относительная гибкость.

4.	Решение: Процессы в приложении короткие во времени и в количестве вызовов и не содержат эволюционирующей логики. Нет смысла применять BPM-движок или BPMS (или более урезанный аналог “Workflow”), это только усложнит разработку и сопровождение. Очереди так же отпадают как мене гибкий вариант. Остановимся на реализации логики бизнес-процесса в приложении в виде автомата конечных состояний. –  это самый простой и быстрый в разработке, в то же время гибкий и тестируемый метод.
5.	Статус: принято
6.	Последствия: это не самый гибкий метод, наблюдаемость зависит от реализации, зато быстрый в разработке, относительно простой в сопровождении и тестируемый.
# Оптимизация для сетей с низким уровнем подключения.
1.	Дата: 28.05.2023
2.	Контекст: Мобильное приложение может использоваться в различных регионах (в т.ч. в малонаселенной или дикой местности в условиях нестабильное связи). Следует уделить особое внимание стабильной работе приложения в условиях периодического отключения сигнала и низкой скорости сети. Проблемы могут возникнуть с загрузкой медиаконтента (медленная сеть), доступ к данным и их хранение (прерывания сети), объем запросов к серверу (серверы перегружаются запросами)
3.	Опции:

    3.1.	“Кеширование” – использовать локальное хранилище, а после восстановления подключения использовать запрос на массовую загрузку. Следует помнить об истечении срока действия кэша
    
    3.2.	“Оптимизация изображений” – использовать WebP вместо JPEG или PNG для ускорения загрузки
    
    3.3.	“Асинхронные вызовы” – использование очередей, когда сеть восстановится все приложения будут отправлены.
    
    3.4.	“Стратегии на стороне сервера” – использовать механизмы кеширования и передачи данных на стороне сервера. Например, Android выпустил серверную функциональность, которая обеспечивает больше доступа к данным на основе разрешений. В соответствии с этой схемой приложение отправляет запросы данных только тогда, когда оно находится на переднем плане или в фоновом режиме, оптимизируя общую производительность.
    
    3.5.	“Обновление с намерением” – выпускать только важные обновления, можно использовать гибридное приложение, когда обновления происходят на сервере.
    3.6.	“Легкое приложение” ¬– создать урезанную версию приложения, оптимизированную для настроек с низким уровнем подключения.
4.	Решение: так или иначе нужно будет использовать кэширование и очереди для доставки сообщений.
5.	Статус: отложено
6.	Последствия: нет

# Нативное, гибридное, Web-приложение.
1.	Дата: 28.05.2023
2.	Контекст: требуется выбрать технологию клиентской части приложения - от этого будет зависеть время разработки и сложность сопровождения.
3.	Опции:
  
    3.1.	“Native” – приложение написано под конкретную платформу на нативном Языке (для Android — Kotlin и Java, для Apple iOS — Objective-C и Swift). Нативное мобильное приложение имеет доступ ко всем нативным технологиям и аппаратным возможностям конкретной платформы. Нативные мобильные приложения необходимо загружать и устанавливать на устройство, например, через официальные магазины Google Play Market и App Store. 
Преимущества:
доступ к аппаратной части устройства (геолокации, камере, микрофону, акселерометру, датчикам освещенности, календарю, push-уведомлениям) и широкий функционал за счет этого;
могут закрыть больше различных запросов заказчиков и пользователей;
данные пользователя можно легко собирать и анализировать;
обычно, работают более стабильно и эффективно с любыми применяемыми устройствами на своей ОС;
нет ограничения функционала скоростью и качеством Интернет-соединения, приложение может работать без выхода в сеть;
лучше подходят для проектов с кастомизированными интерфейсами и сложной бизнес-логикой.
Недостатки:
дорогие в разработке;
для разработки нужно больше времени;
проходят верификацию каждым магазином приложений;
охватывают мало платформ и несовместимы с другими операционными системами;
даже легкие изменения требуют регулярных обновлений.  

    3.2.	“Web” – приложение работает через веб-браузер на устройстве пользователя. По сути, это кастомизированный веб-сайт, который выглядит как нативное приложение, но размещается не на устройстве пользователя.
Преимущества:
веб-приложения могут функционировать на платформе с любой ОС;
разработчикам не нужно утверждать приложение с магазинами;
цикл разработки CSS, HTML и JavaScript идет в разы быстрее.
Недостатки:
нет доступа к аппаратной части устройств пользователей, что значительно урезает функционал веб-приложений (например, невозможно сделать веб-приложение, которое задействует акселерометр на устройстве или включит камеру);
использование возможно только через Интернет и зависит от его наличия, скорости и стабильной работы;
приложения не каталогизированы в одном месте и их сложнее искать.        

    3.3.	“Hybrid”. Гибридное приложение — компромисс между нативными и веб-приложениями. Оно размещаются в рамках нативного приложения и работают через WebView. У него есть доступ к информации на устройстве пользователя. WebView — это системный компонент, который открывает веб-страницы в рамках других приложений. Выглядит и используются как нативное приложения: его можно скачать из магазина и установить на устройство. Приложения имеет доступ к данным пользователя, но обычно само не хранит свои данные непосредственно на устройстве пользователя.
Преимущества:
широкий функционал и высокая степень кастомизации;
можно создать приложение, которое будет работать с несколькими платформами;
удешевляют и ускоряют разработку MVP или несложного готового продукта для заказчиков;
являются серединным решением между функционалом и производительностью нативного приложения и дешевизной веб-приложения.
Недостатки:
слишком сложные приложения лучше делать нативными, как и приложения с громоздкими визуальными решениями вроде игр;
разработка потребует больше времени и усилий, чтобы гибридное приложение выглядело и ощущалось как нативное;
магазины приложений отклоняют недостаточно хорошо работающие гибридные приложения и важно соблюдать стандарты качества.

    3.4 “Cross-platform”.  Кросс-платформенная разработка приложений значит, что приложение разработано с такой технологией/языком/фреймворком, который позволяет использовать его сразу на нескольких разных ОС — Android, iOS, Windows, Linux и т. д. Например, приложения, разработанные с использованием React-Native, могут работать на Android и iOS. Разработка гибридных приложений значит, что приложение разработано с использованием нескольких языков/технологий, но это не всегда означает, что оно будет кросс-платформенным. Приложения могут быть гибридными, но не обязательно будут считаться кросс-платформенными. Приложение может считаться кросс-платформенным, но не обязательно будет гибридным, оно может быть веб-приложением или даже нативным (например, фреймворк React Native использует среду выполнения JavaScript для рендеринга JavaScript-кода и возможности последующей публикации приложения как в Google Play Market, так и в App Store). Аналогично, приложения могут быть гибридными и иметь свойство кроссплатформенности одновременно (например, React-Native + родной язык платформы). Подходы при разработке мобильного приложения можно комбинировать. Например, создавать критичные к производительности экраны на нативных технологиях, а второстепенные — на кросс-платформенных.
Преимущества:
кросс-платформенная разработка намного быстрее разработки нативных мобильных приложений сразу под несколько разных платформ по отдельности;
отлично подходит для стартапов, которым необходимо быстрее выйти на рынок с MVP, чтобы проверить теорию;
подходит для создания ивент-приложений, например, для деловых конференций, ярмарок и т. д. из-за быстроты создания;
кросс-платформенная разработка чаще способствует более эффективному развитию разработчиков, так как задействует работу с несколькими технологиями и средами, а также стимулирует навык решения проблем;
кросс-платформенность удобна при написании простого приложения с малым количеством экранов для нескольких платформ (идеальная задача для кросс платформы — простая мобильная игра).
Недостатки:
iOS и Android существенно различаются и это вызывает сложности в разработке и множество лагов в работе готового приложения (чаще это касается элементов интерфейса и их рендеринга, показатели Animation FPS и Animation RAM могут отличаться на 3-5 раз в худшую сторону);
кросс-платформенные приложения чаще крашатся, дольше думают и тормозят;
поддерживать кросс-платформенный код сложнее — обновление систем приводит к частому обновлению программных интерфейсов, что требует больше времени разработчика
в кросс-платформенном мире небольшое сообщество и часто приходится решать проблемы самостоятельно, высокий риск столкнуться с проблемой, о которой мало кто знает;
разработка кроссплатформенных приложений может значительно упростить жизнь и сэкономить деньги заказчику и владельцам бизнеса, которые ограничены в финансовых возможностях, и добавить головной боли разработчику;
но кросс-платформенное приложение может потребовать огромных усилий дразработчиков и больших вложений заказчика при переходе из MVP в готовый продукт и при масштабировании продукта;
кросс-платформенное приложение может использовать больше ресурса батареи устройства пользователя, причем, даже в полтора раза, что неудобно при частом использовании приложения.

4.	Решение: web-приложение не подходит т.к. не позволяет использовать аппаратные возможности (подключать датчики). Кроссплатформенные приложения отпадают из-за более медленной работы, сложности при развитии от MVP до полной версии и малого сообщества (вероятность столкнуться с проблемой, о которой не будет информации). Чисто гибридное приложение (весь контент представлен в виде WebView не подойдет из-за высокой вероятности работы с сетями с низким уровнем подключения.) Но в гибридном приложении часть экранов, может быть, нативными, а часть с использованием WebView – в частности это позволит производить обновления на сервере и таким образом пользователю не нужно будет их скачивать, а разработчику не нужна верификация обновлений магазином приложений. Пока что у чисто нативного или гибридного (с частью нативного функционала) приложения нет очевидных преимуществ. Решено использовать нативное приложение с возможным гибридным функционалом (часть экранов будет работать через WebView).
5.	Статус: отложено
6.	Последствия: потребуется отдельная разработка для разных платформ – это будет дольше и дороже, но приложение будет работать быстро и стабильно.


# Интеграция с другими приложениями – переход между экранами различных приложений.
1.	Дата: 28.05.2023
2.	Контекст: Интеграция между мобильными приложениями — это процесс соединения одного приложения с другим для оптимизации и обмена проверенными данными через API. Триггеры в одном приложении вызывают действия в другом; данные из одного сопоставляются и передаются в другой. Нужно решить как организовать переход между экранами различных приложений, например переxод в магазин из инвентаря/промоакций (переход на определенную страницу в другом приложении)
3.	Опции:

    3.1.	“Universal (https://developer.apple.com/ios/universal-links/ )/App links (https://developer.android.com/training/app-links )”. Универсальные ссылки (iOS) или ссылки на приложение (Android) могут открываться в мобильном приложении, если зарегистрировано какое-то мобильное приложение для этого домена.  Универсальные ссылки/ссылки на приложения сообщают веб-браузеру, что делать, если приложение, на которое вы хотите установить ссылку, не установлено. При использовании универсальных ссылок гиперссылка перенаправляет пользователя мобильного устройства либо на контент на мобильном веб-сайте, либо на аналогичный контент в мобильном приложении, в зависимости от того, установлено приложение или нет. Сама ссылка указывает веб-браузеру на карту ссылок/схему URL/схему ссылок приложения на защищенном веб-сайте, которая определяет, куда перенаправляются пользователи в зависимости от их состояния установки.

    3.2.	Deep Linking (глубинное связывание) — технология, благодаря которой пользователь может перемещаться между приложениями в заранее определенные разделы. Принцип работы Deep Linking заключается в следующем: пользователь инициирует переход по URL, ресурс, находящийся по этой URL, определяет операционную систему и соответствующим образом осуществляет переход в приложение в заранее определенный раздел.

    3.3.	App Extensions (iOS) (https://developer.apple.com/app-extensions/ ) Расширения приложений позволяют расширить пользовательские функции и содержимое за пределы приложения и сделать их доступными для пользователей, когда они взаимодействуют с другими приложениями или системой. Например, приложение может отображаться в виде виджета на главном экране, можно добавлять новые кнопки в лист действий, или автоматически обновлять учетные записи пользователей для использования надежных паролей.

    3.4.	Intent/Services (Android) (https://developer.android.com/training/basics/intents ) Используется для того что бы начать активность в том же или в другом приложении.

    3.5.	Swarm (https://gabrielarpino.github.io/files/riss.pdf) – распределенная система приложений и задач, предназначенная для интернета вещей для формирования коллективного поведения IoT (приложения могут быть двух типов – координатор и агент) 

4.	Решение: выберем Deep Linking как более простой и универсальный способ по сравнению с App Extensions/Intent. А вообще если только не использовать Swarm, то это не архитектурное решение, можно отложить принятие решения.
5.	Статус: отложено
6.	Последствия: возможны ограничения из-за настроек безопасности на новых версиях Android.

# Интеграция с другими приложениями – бесшовный переход между приложениями, авторизация и аутентификация.

1.	Дата: 29.05.2023
2.	Контекст: при переходе между приложениями (например, из инвентаря в приложение с магазином должно происходить бесшовно – пользователь не должен вводить логин/пароль)
3.	Опции: 
    
    3.1.	Single sign on (SSO) – отдельный сервис для аутентификации и авторизации во всех приложениях компании.
    
    3.2.	Комплексное нативное облачное решение, например Azure Active Directory - облачное служба управления удостоверениями и доступом. Имеет такие функции, как условный доступ, Azure AD Многофакторная идентификация (MFA), SSO, etc. упрощают управление удостоверениями и доступом, а также обеспечивают более высокий уровень безопасности.
    
    3.3.	Менеджер паролей для всех приложений компании, может быть в виде SDK (встроенным в приложение – при переходе из одного приложения в другое данные для логина будут автоматически заполняться. Пример Keeper (https://www.keepersecurity.com/ru_RU/resources/how-keeper-completes-single-sign-on.html) - Каждому пользователю предоставляется безопасное облачное хранилище для хранения паролей и другой критически важной информации, такой как ключи шифрования и цифровые сертификаты. Keeper генерирует надежные пароли случайным образом и автоматически вводит их за пользователя. Это экономит время и устраняет необходимость повторно использовать и помнить пароли. Может использоваться совместно с SSO для интеграции со старыми приложениями, не поддерживающими протоколы SAML/ОAuth.
    
    3.4.	Опционально можно добавить логин с помощью третьей стороны (например, через аккаунт google или facebook)
    
    3.5.	Если речь идет только об интеграции мобильных приложений, то можно во всех приложениях использовать биометрию для входа (например автоматический вход по лицу) Пример: https://1password.com/ru/developers

4.	Решение: так или иначе все технологии имеют в своей основе SSO или могут быть дополнением к SSO. Будем использовать SSO – единый сервис входа для всех приложений компании собственной разработки, без использования специфических фреймворков. 
5.	Статус: принято
6.	Последствия: ко всем приложениям будут применяться единые настройки входа, если, например для входа в магазин двухфакторная аутентификация выглядит уместно, то для приложения с тренировками – она может показаться излишней.

# Мониторинг: стратегия сбора логов

1.	Дата: 01.06.2023
2. Контекст: требуется выбрать стратегию сбора логов - где размещать агрегаторы и как они будут между собой взаимодействовать
3. Опции:

    3.1. Прямая запись в агрегатор логов. Недостатки: много сетевых подключений и фиксированный адрес агрегатора, может произойти перегрузка и отказ при значительном росте сети

    3.2. Агрегатор рядом с сервисами. Это достаточно гибкая конфигурация, в ней меньше настроек и нагрузки на агрегатор. Минусы: большее потребление ресурсов и количество компонент.

    3.3. Агрегатор на стороне доставки. Минусы: изменения на стороне принимающей стороны приводят в изменению конфигурации поставщиков логов, большое количество соединение и , соответственно, меньшая производительность, сложное масштабирование.
    
    3.4. Агрегатор ну двух сторонах- рядом с сервисами и на стороне доставки. Изменения на принимающей стороне не требуют изменений в источнике, лучше производительность и отказоустойчивость, проще обслуживание. Минусы: требуется большее количество ресурсов и сложнее конфигурация.

4. Решение: агрегатор будет размещаться рядом с сервисами-это позволит быстрее производить по иск по локальным логи и упростит систему (упростиот настройки и уменьшит количество сетевых соединений). Возможна агрегация на двух сторонах если в этом возникнет необходимость.
5. Статус: отложен
6. Последствия: Более сложная система (и соответственно больше точек отказа) но проще сопровождение.

# Развертывание: выбор облачного подхода

1.	Дата: 01.06.2023
2. Контекст: требуется выбрать подход к размещению облачного решения, от этого может зависеть стек досткпных технологий
3. Опции:

    3.1.	Традиционный подход к управлению инфраструктурой: Фиксированные ресурсы – ресурсы хранения, вычислительные и сетевые ресурсы заранее предопределены и фиксированы;

    3.2.	Платформа как сервис (PaaS): Предоставление полноценной среды для разработки, тестирования, развертывания, размещения и обслуживания приложений в облаке для организации процессов, разработки и тестирования; Поставщик услуг запускает и управляет средами от уровня инфраструктуры до уровня прикладных служб в стеке;

    3.3.	Инструментальная платформа как сервис (APaaS): Предоставление компонентов приложений, инструментов развертывания и совместной работы, предварительно настроенных шаблонов и виджетов для быстрого создания приложений. Поставщик услуг запускает и управляет средами и процессом от инфраструктуры до уровня прикладных служб, включая некоторый программный код и инструменты, а также управление данными и пользовательскими интерфейсами;

    3.4.	Инфраструктура как сервис (IaaS): Предоставление физического пространства ЦОД, а также физических и виртуальных процессоров, дискового пространства и служб баз данных в качестве услуги; Возможность выбора наиболее удобной модели финансирования для оптимизации затрат; Переход к модели потребления инфраструктурных услуг по подписке.

    3.5.	Программное обеспечение как сервис (SaaS). Это полностью готовое решение, которое сразу же можно использовать. Примерами реализации услуг по принципу SaaS являются конструкторы сайтов, почтовые сервисы, различные CRM-системы, 1С в облаке, планировщик Google и т.д. 

    3.6.	Гиперконвенгентные решения   представляет собой единую программно-определяемую среду, которая сочетает в себе элементы традиционного оборудования, устанавливаемого в ЦОД. Является интегрированным решение на базе ПО и серверов х86, благодаря чему способно заменять дорогое специализированное оборудование

4. Решение: Использовать Инфраструктура как сервис (IaaS) - это позволит избежать зависимости от проприетарных компонент, тем более что возможно потребуется развертывание и работа в различных регионах (юрисдикциях) - требуется возможность быстрой смены облачного провайдера (Поэтому все что предоставляет проприетарные компоненты (PaaS, APaaS) не подходит)  SaaS имеет ограниченные возможности, а при традиционном подходе не будет сопровождения с стороны облачного провайдера.
5. Статус: принято
6. Последствия: Не будет ограничений на стек используемых технологий, но придется самостоятельно поддерживать некоторые компоненты.

# Мониторинг: метрики

1.	Дата: 01.06.2023
2. Контекст: требуется выбрать стратегию сбора метрик и оповещения
3. Опции:

    3.1.	Что собирать:

        3.1.1.	Сбор и анализ проблем с производительностью инфраструктуры (железо, сеть).

        3.1.2.	Сбор и анализ высокоуровневых данных (веб сервисы, БД, очереди и etc.).

        3.1.3.	Сбор и анализ бизнес-метрик.

    3.2.	Как собирать:

        3.2.1.	USE Method — сбор метрик: Utilization — время или процент использования ресурса, занятого «полезной работой»; Saturation — насыщенность, то есть количество отложенной или поставленной в очередь «работы»; Errors — количество ошибок в работе компонента. Применяется для анализа проблем с производительностью. Нужно для выбора и анализа низкоуровневых метрик, например утилизацию процессора, количество свободного места, памяти, превышение допустимой температуры оборудования или нагрузка самой сети. (например, Zabbix)

        3.2.2.	RED Method — сбор метрик: Rate — количество запросов в единицу времени (например, rps на микросервис или сервер); Errors — количество ошибок; Duration (оно же latency) — время обработки одного запроса. Нужно использовать для более высокоуровневых сервисов, которые обслуживают запросы. Например, различные веб сервисы, запросы базы данных, очереди и т.д. (например, Prometheus)

        3.2.3.	LTES method — сбор метрик: Latency — время на обработку одного запроса (с разделением на успешные и ошибочные запросы)); Traffic — количество запросов к компоненту (для веб-сервера это могут http-запросы, для базы данных — транзакции и т.п.); Errors — количество ошибок; Saturation — здесь это количественная метрика, отражающая, насколько компонент использует свои ресурсы и сколько у него «работы в очереди».

        3.2.4.	UCA method — сбор метрик Users, Conversions, Activity. Это может быть количество активных пользователей, количество переходов в магазин, количество пользователей сейчас/среднее в день/месяц и т.д. (например, Google Analytics)

    3.3.	Как оповещать:

        3.3.1.	SLI (Service level indicators) — набор ключевых метрик, по которым можно определить жизненный статус сервиса, его производительность, «удовлетворенность» конечных пользователей работой сервиса. Например, в SLI может входить количество 500-х ошибок или количество активных пользователей.

        3.3.2.	SLA (Service level agreement) — так называемое «соглашение об уровне доступности сервиса», которое определяется как ВНЕШНЕЕ обязательство перед конечным пользователем или клиентом. Например, SLA нашей круглосуточной техподдержки обычно составляет 15 минут — за это время мы обязуемся отреагировать на запрос или инцидент клиента, и это не зависит от внутренних обстоятельств. 

        3.3.3.	SLO (Service level objectives) — набор целевых, «желаемых» значений SLI, выход за пределы которых может привести к нарушению SLA конкретного сервиса или компонента. Максимально допустимое отклонение от «идеальных» показателей в данной концепции называется Error Budget (право на ошибку). Как пример, это может быть: максимальное количество 500-х ошибок за 5 минут, максимальное время недоступности веб-страницы, максимально допустимая нагрузка на процессор и т д.

4. Решение: Будем собирать метрики приложения по методу LTES и оповещеть по SLA. Предположительный инструмент - Prometheus.
5. Статус: отложено
6. Последствия: от выбора метрик будет зависеть простота обнаружение ошибок и отладки.

# Регистрация и обнаружение сервисов

1.	Дата: 04.06.2023
2. Контекст: Нужно выбрать модель регистрации и обнаружения сервисов для масштабирования.
3. Опции:

    3.1.	Обнаружение:

        3.1.1.	“Статическая адресация” – В каждом сервисе вручную прописать какие сервисы он использует и connection string для них. Реплики добавлять через Load Balancer. Нужно добавлять сервисы вручную и возрастает сложность сети и увеличивается Latency.

        3.1.2.	“Статическая адресация +DNS” Сервис обращается на DNS и тот перенаправляет его на нужный сервис. Так же нужно добавлять сервисы вручную и возрастает сложность сети и увеличивается Latency. 

        3.1.3.	“Client side Service Discovery” Сервис самостоятельно сообщает о том, что он готов к работе. Клиент запрашивает информацию о доступных сервисах и принимает решение куда обратиться. Клиент должен иметь встроенный Load Balancer. Это простое решение, но жестко связывает клиент с Service Registry и клиент не узнает если сервис упадет, т.к. сервис сможет оповестить о только оп плановом завершении работы.

        3.1.4.	“Server side Service Discovery” Клиент не связан с Service Registry, но балансировщик нагрузки становится узким местом. Приложение регистрируется в Service Registry, когда появляется в сети. Клиент обращается к Load Balancer, тот в свою очередь обращается в Service Registry что бы узнать, где находится сервис, балансирует нагрузку и перенаправляет запрос к нужной реплике сервиса. (NGINX, k8s, Traefik, etc.)

    3.2. Регистрация:

        3.2.1.	“Самостоятельная регистрация” – сервис самостоятельно регистрируется в Service Registry

        3.2.2.	“Регистрация отдельным компонентом” – отдельный компонент т.н. “Registrar” или “Сервис публикации” постоянно опрашивает сеть на предмет новых сервисов или подписывается на события контроллера сервиса. Клиент не привязан к Service Registry но это дополнительный компонент для поддержки.


    3.3.	Как сервис будет оповещать о готовности к работе:

        3.3.1.	“Healthcheck/Liveness” – “Registrar” опрашивает сервис о его состоянии и получает в ответ маркер, что сервис может отвечать на запросы и информацию об общем состоянии.

        3.3.2.	“Handshake/Readiness” — “Registrar” опрашивает сервис о его состоянии и получает в ответ что бизнес-операции могут выполняться за приемлемое время.

4. Решение: Будем использовать Server-side Service discovery, если все сервисы расположены в k8s, если не все сервисы в одной среде, то придется использовать саморегистрацию сервисов (например, Eureka). При этом сервисы могут самостоятельно регистрироваться в Service Discovery пока их мало или с помощью специального Сервиса публикации (вариант с ESB).
5. Статус: отложено
6. Последствия: от этого решения будет зависеть сложность разработки и сопровождения.

# Использование стандартов Observability.

1.	Дата: 04.06.2023
2.	Контекст: можно использовать отдельные приложения для сборf метрик, логов, трассировки или использовать единый сборщик для всей телеметрии и стандарт Open Telemetry 
3.	Опции: 
    
    3.1.	Использовать отдельное ПО Для сбора метрик, логов, трассировки. Это проще, разработка будет идти быстрее, так же каждый сборщик будет работать автономно, т.е. не будет единой точки отказа для всей телеметрии, но в дальнейшем будет сложно заменить выбранное ПО, если оно престанет отвечать требованиям
    
    3.2.	Использовать стандарт OpenTelemetry, актуальный стандарт на основе OpenTracing и Open Census. В Данном случае будет использоваться единый коллектор для всей телеметрии (проще в сопровождении, но это единая точка отказа), а само ПО для обработки телеметрии можно будет впоследствии заменить
    
4.	Решение: использовать стандарт OpenTelemetry. Новые системы появляются часто и большинство из них поддерживает этот стандарт, можно будет заменить систему без проблем. 
5.	Статус: принято
6.	Последствия: Меньше компонентов – проще в поддержка, но сложнее в разработка.

# Межпроцессное взаимодействие: Синхронные или асинхронные API.

1.	Дата: 10.06.2023
2.	Контекст: по разным причинам (работа с сетями с низким уровнем подключения, резкие всплески количества пользователей, географическое распространение) так или иначе нужно будет использовать очереди сообщений. Нужно выбрать  как применить очереди. Существует ограничение что некоторые сервисы могут иметь синхронные REST API так что очередям сообщений придется работвть с ними.
3.	Опции: 
    
    3.1.	стили взаимодействия: 
        
        3.1.1 один к одному - каждый клиентский запрос обрабатывается одним сервисом .
        
        3.1.2 один ко многим (или модель издатель-подписчики) - каждый запрос обрабатывается несколькоими сервисами
    
    3.2.Синхронность
    
        3.2.1 синхронное - клиент ждет ответ и может заблокироваться на время ожидания (запрос/ответ). синхронное взаимодействие может быть реализовано как с помощью REST так и с помощью сообщений.
        
        3.2.2 асинхронное -клиент не блокируется, ответ приходит не сразу (один к одному: асинхронный запрос/ответ, однонаправленные уведомления или один ко многим: издатель-подписчик, издатель/асинхроныые ответы )

    3.2.Формат сообщений:

        3.3.1 текстовые (JSON, XML).
        
        3.3.2 Двоичные (Protocol Buffers, Avro, Thrift)
    
    3.4. Основные способы Взаимодействие 
    
        3.4.1 На основе Удаленного вызова процедур RPC (может быть асинхронным), REST (синхронное взаимодействие запрос/ответ) 
        
        3.4.2 Взаимодействие с помощью асинхронного обмена сообщениями, обычно используется брокер сообщений
    
    3.5.	Механизмы обмена сообщениямию Сообщение состоит из заголовка и тела.Загалогвок содержит пары ключ-значение идентификатор сообщения и необязательный обратный адрес в котором указан канал куда следует записывать ответ. Сообщения могут быть разных типов: документ, команда и событие. Каналы могут быть точка-точка и издатель-подписчик:

        3.5.1 асинхронное взаимодействие запрос/ответ. Клиент и сервис обменимаются парными сообщениями. Клиент отправляет сообщение в канал точка-точка, принадлежащий сервису, командное сообщение с указанием операции и ее параметров и канала, куда следует поместить ответ. Сервис обрабатывает запрос и возвращает в канал точка-точку принадлежащий клменту, ответное сообщение с результатом 
        
        3.5.2 однонаправленные уведомления. клиент шлет сообщение (обычно командное) в канал точка-точка принадлежащий сервису.

        3.5.2 Реализация шаблона "Издатель-подписчик".Клиент публикует в канали типа издатель подписчик сообщение , которое считывается несколькими потребителями. Обычно сервисы используют этот шабло для публикации доменных событий.

        3.5.2 Реализация шаблона "Издатель/асинхронные ответы".Это высокоуровневый стиль взаимодействия, сочетает шаблоны "издатель-подписчик" и "запрос.ответ". Клиент публикует в канале типа "издатель-подписчик" сообщение с каналом ответа в заголовке. Клиент записывает ответное сообщение с идентификатором сообветствия в канал ответа. Клиент принимает ответы и сверяет их с запросом с помощьтю идентификатора соответствия.
    
4.	Решение: Будем использовать модель взаимодействия "Издатель/асинхронные ответы". При этом сами сервисы могут предоставлять синхронный REST API (например в целях ускорения разраблотки и упрощения тестирования, а так же из-за внешних ограничений (сервис может исползовать внутри себя внешние REST API)). Будем использовать брокер сообщений а не просто очередь. (брокер состоит из элементов Producer, MQ, Consumer) При этом Consumer может вызывать синхронный REST API. API Gateway, и брокер сообщений являются обычными микросервисами в k8s и могут реплицироваться в нужных масштабах. При необходимости можно  реализовать и на API Gateway REST API - в этом случае этот API не будет иметь таймаутов и API Gateway будет реплицироваться после достижения определенногочисла подключен? далее API Gateway преобразует запрос в асинхронный пропускает через брокер сообщений и Consumer снова вызывает REST API (ЭтотAPI уже имеет таймауты). т.о. при скачках количества пользователей просто реплицируется API Gateway и висит с открытыми подключениями, в то время как сами запросы стоят в очереди.
5. Статус: принято
6.	Последствия: Усложняется инфраструктура, но выше совместимость с другими системами. Снаружи это выглядит как обычный REST API.

# Консистентность данных.

1.	Дата: 04.06.2023
2.	Контекст: Приложение будет иметь географически распределенную БД. Следует обратить особое внимание на поддержание транзакционности данных
3.	Опции: 
    
    3.1.	Использование ACID транзакций (в SQL БД) - так или иначе используется двухфазовый/трехфазовый коммит
    
    3.2.	Использование шаблона "Saga"

    3.2.	Использование кворума: в любой момент времени времени каждая реплика выдает результат голосования всех реплик. Т. е все реплики всегда выдают одинаковый ответ - данные всегда консистентны (например так работает БД Elasticsearch).

    3.2.	Distributed SQL: это NoSQL БД хранящие пары "ключ значения", предоставляющая при этом наружу SQL API (для потребителя выблядит как SQL БД). Использует различные алгоритмы консенсусы (развитие идеи кворума, данные всегда консистентны)
    
4.	Решение: Будем использовать Cloud-Native решение Distributed SQL. Возьмем самую распространенную Open Source БД от Google - cocroach БД. 
5.	Статус: принято
6.	Последствия: на данный момент технология Distributed SQL является относительно новой - нет опыта долгосрочного использования в больших проектах, соответственно имеются риски, но данное приложение не является критичным для компании. так же Cocroach DB - одна из первых (2015) и развивалась из первой (Spanner от Google - это коммерческая БД, есть пример использования в Uber). Все данные реплицируются минимум три раза - это увеличит дисковое пространство (ведь не все данные одинаково важны). Зато это раб отает быстро и надежно и не требует работы странзакциями сос тороны разработчива - это коробочное решение.

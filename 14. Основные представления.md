# Concurrency view
Для хранения данных выберем “Cloud-Native” решение: будем применять подход “Distributed SQL”. Он гарантирует согласованность данных (consistency), как если бы транзакции проходили последовательно. Рассмотрим пример с использованием CockroachDB – open source Distributed SQL БД от Google. Для обеспечения согласованности данных CockroachDB требует, чтобы все операции записи распространялись на кворум данных, для этого используется протокол согласия Raft.

CocroaccDB состоит из следующих слоев:

*“SQL layer”* выставляет наружу SQL API и конвертирует SQL-запросы в низкоуровневые запросы на чтение/запись в нижележащий “слой Key-Value”. Состоит из следующих компонент: 

    “SQL API” – формирует пользовательский интерфейс, 

    “Parser” – конвертирует SQL в abstract layer tree (AST), 

    “Cost-based optimizer” – оптимизирует AST и конвертирует в логический запрос, 

    “Physical planner” – конвертирует логический запрос в физический на одной или нескольких нодах, 

    “SQL Execution Engine” – выполняет физический запрос – чтение/запись в следующий “Слой Key-Value”.

*“Transaction layer”* реализует поддержку ACID транзакций, путем координации конкурентных операций. Используется протокол коммитов “Parallel Commits”.

*“Distribution layer”* делает всю информацию в БД доступной из любой ноды .

*“Distribution layer”* – копирует информацию между нодами для поддержания согласованности. Используется протокол консенсуса Raft.

*“Storage Layer”* – записывает информацию на диск. Используется движок хранения информации “Pebble”. Информация хранится в формате “Ключ-значение”

Каждый кластер для одного региона имеет как минимум три узла, распределенных по трем зонам доступности (*“Availability Zone”*, AZ) в регионе поставщика облачных услуг. Кластеры с несколькими регионами аналогичны кластерам с одним регионом, где узлы распределены по трем или более зонам доступности в каждом регионе

Перед кластером CocroachDB ставится Load Balancer и Proxy выполняющий роль API Gateway и дополнительной балансировки.
